{"version":3,"sources":["webpack:///shortcode-tokenizer.js","webpack:///webpack/bootstrap 60dc1c00a4c07e144bd5","webpack:///./src/shortcode-tokenizer.js"],"names":["module","exports","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","_toConsumableArray","arr","Array","isArray","arr2","length","from","_classCallCheck","instance","Constructor","TypeError","getTokenType","str","CLOSE","SELF_CLOSING","OPEN","castValue","value","test","Number","toLowerCase","replace","Token","_typeof","Symbol","iterator","obj","constructor","_createClass","defineProperties","target","props","descriptor","writable","key","protoProps","staticProps","RX_KEY","RX_PARAMS","RX_OPEN","RX_SELFCLOSING","rxParams","RegExp","substring","rxEnclosure","rxOpen","rxClose","rxSelfclosing","type","body","pos","arguments","undefined","this","children","params","isClosed","init","match","matchBody","initName","initParams","paramStr","reduce","paramToken","trim","equal","indexOf","result","typeOfValue","value_","computedParams","buildParams","rx","SyntaxError","token","ShortcodeTokenizer","input","options","strict","skipWhiteSpace","assign","buf","originalBuf","Error","tokens","allTokens","_next","push","apply","stack","ast","parent","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","next","done","canClose","pop","err","return","build","childs","map","child","toString","join","index","console","warn","set","TEXT","ERROR"],"mappings":"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","file":"shortcode-tokenizer.js","sourcesContent":["module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/*!******************************************!*\\\n  !*** multi ./src/shortcode-tokenizer.js ***!\n  \\******************************************/\n/*! dynamic exports provided */\n/*! all exports used */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(/*! /Users/thomassimons/Projects/shortcode-tokenizer/src/shortcode-tokenizer.js */1);\n\n\n/***/ }),\n/* 1 */\n/*!************************************!*\\\n  !*** ./src/shortcode-tokenizer.js ***!\n  \\************************************/\n/*! exports provided: Token, default */\n/*! all exports used */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Token\", function() { return Token; });\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/** @module ShortcodeTokenizer */\n\n/* tokens */\nvar TEXT = 'TEXT';\nvar ERROR = 'ERROR';\nvar OPEN = 'OPEN';\nvar CLOSE = 'CLOSE';\nvar SELF_CLOSING = 'SELF_CLOSING';\n\n/* eslint-disable */\n\n/* matches code name */\nvar RX_KEY = '[a-zA-Z][a-zA-Z0-9_-]*';\n\n/* matches paramters */\nvar RX_PARAM = RX_KEY + '=\\\\d+\\\\.\\\\d+' + // floats\n'|' + RX_KEY + '=\\\\d+' + // ints\n'|' + RX_KEY + '=(true|false|yes|no)' + // bools\n'|' + RX_KEY + '=\"[^\\\\]\"]*(<.*\".*)?\"' + // double-qouted strings\n'|' + RX_KEY + '=\\'[^\\\\]\\']*(<.*\\'.*)?\\'' + // single-qouted strings\n'|' + RX_KEY; // flags\nvar RX_PARAMS = '(?:(?:' + RX_PARAM + ')(?:(?!\\\\s+/?\\\\])\\\\s|))+';\n\n/* matches all code token types, used for quickly\n   finding potentia code tokens */\nvar RX_ENCLOSURE = '\\\\[\\\\/?[a-zA-Z][^\\\\]]+\\\\]';\n/* matches opening code tokens [row] */\nvar RX_OPEN = '\\\\[(' + RX_KEY + ')(\\\\s' + RX_PARAMS + ')?\\\\]';\n/* matches self-closing code tokens [row/] */\nvar RX_SELFCLOSING = '\\\\[(' + RX_KEY + ')(\\\\s' + RX_PARAMS + ')?\\\\s?\\\\/\\\\]';\n/* matches close code tokens [/row] */\nvar RX_CLOSE = '\\\\[\\\\/(' + RX_KEY + ')\\\\]';\n\n/* case-insensitive regular expressions */\nvar rxParams = new RegExp(RX_PARAMS.substring(0, RX_PARAMS.length - 1), 'ig');\nvar rxEnclosure = new RegExp(RX_ENCLOSURE, 'i');\nvar rxOpen = new RegExp(RX_OPEN, 'i');\nvar rxClose = new RegExp(RX_CLOSE, 'i');\nvar rxSelfclosing = new RegExp(RX_SELFCLOSING, 'i');\n\n/* eslint-enable */\n\n/**\n * Get token type based on token-string.\n *\n * Note: assuming that this is not a TEXT token\n *\n * @param {string} str\n * @returns {string} token type\n */\nfunction getTokenType(str) {\n  if (str[1] === '/') {\n    return CLOSE;\n  }\n  if (str[str.length - 2] === '/') {\n    return SELF_CLOSING;\n  }\n  return OPEN;\n}\n\n/**\n * Casts input string to native types.\n *\n * @param {string} value\n * @returns {*} mixed value\n */\nfunction castValue(value) {\n  if (/^\\d+$/.test(value)) return Number(value);\n  if (/^\\d+.\\d+$/.test(value)) return Number(value);\n  if (/^(true|false|yes|no)$/i.test(value)) {\n    value = value.toLowerCase();\n    return value === 'true' || value === 'yes';\n  }\n  return value.replace(/(^['\"]|['\"]$)/g, '');\n}\n\n/**\n * Token class is used both as a token during tokenization/lexing\n * and as a node in the resulting AST.\n */\nvar Token = function () {\n  function Token(type, body) {\n    var pos = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n    _classCallCheck(this, Token);\n\n    this.name = null;\n    this.type = type;\n    this.body = body;\n    this.pos = pos;\n    this.children = [];\n    this.params = {};\n    this.isClosed = type === SELF_CLOSING;\n    this.init();\n  }\n\n  /**\n   * @access private\n   */\n\n\n  _createClass(Token, [{\n    key: 'init',\n    value: function init() {\n      if (this.type !== TEXT && this.type !== ERROR) {\n        var match = this.matchBody();\n        this.initName(match);\n        if (match[2]) {\n          this.initParams(match[2]);\n        }\n      }\n    }\n\n    /**\n     * @access private\n     */\n\n  }, {\n    key: 'initName',\n    value: function initName(match) {\n      this.name = match[1];\n    }\n\n    /**\n     * @access private\n     */\n\n  }, {\n    key: 'initParams',\n    value: function initParams(paramStr) {\n      var match = paramStr.match(rxParams);\n      this.params = match.reduce(function (params, paramToken) {\n        paramToken = paramToken.trim();\n        var equal = paramToken.indexOf('=');\n        if (!~equal) {\n          params[paramToken] = true;\n        } else {\n          params[paramToken.substring(0, equal)] = castValue(paramToken.substring(equal + 1));\n        }\n        return params;\n      }, {});\n    }\n\n    /**\n     * @return {string}\n     */\n\n  }, {\n    key: 'buildParams',\n    value: function buildParams() {\n      var result = '';\n\n      for (var key in this.params) {\n        if (this.params.hasOwnProperty(key)) {\n          var value = this.params[key];\n          var typeOfValue = typeof value === 'undefined' ? 'undefined' : _typeof(value);\n          if (typeOfValue === 'string') {\n            result = result + ' ' + key + '=\"' + value + '\"';\n          } else if (typeOfValue === 'boolean') {\n            var value_ = value ? 'true' : 'false';\n            result = result + ' ' + key + '=' + value_;\n          } else {\n            result = result + ' ' + key + '=' + value;\n          }\n        }\n      }\n\n      return result;\n    }\n\n    /**\n     * Convert token to string.\n     *\n     * @param {object|string|null} [params=null]\n     * @return {string}\n     */\n\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n      if (params instanceof Object) {\n        this.params = params;\n      }\n\n      var computedParams = typeof params === 'string' ? ' ' + params.trim() : this.buildParams();\n\n      switch (this.type) {\n        case TEXT:\n          return this.body;\n\n        case OPEN:\n          return '[' + this.name + computedParams + ']' + (this.children.length ? '{slot}' : '') + '[/' + this.name + ']';\n\n        case SELF_CLOSING:\n          return '[' + this.name + computedParams + '/]';\n\n        default:\n          return '';\n      }\n    }\n\n    /**\n     * @access private\n     */\n\n  }, {\n    key: 'matchBody',\n    value: function matchBody() {\n      var rx = void 0;\n      if (this.type === CLOSE) {\n        rx = rxClose;\n      } else if (this.type === OPEN) {\n        rx = rxOpen;\n      } else if (this.type === SELF_CLOSING) {\n        rx = rxSelfclosing;\n      } else {\n        throw new SyntaxError('Unknown token: ' + this.type);\n      }\n\n      var match = this.body.match(rx);\n      if (match === null) {\n        throw new SyntaxError('Invalid ' + this.type + ' token: ' + this.body);\n      }\n      return match;\n    }\n\n    /**\n     * Determines if this token can close the param token.\n     *\n     * @access public\n     * @param {Token} token another token\n     * @returns {boolean}\n     */\n\n  }, {\n    key: 'canClose',\n    value: function canClose(token) {\n      return this.name === token.name;\n    }\n  }]);\n\n  return Token;\n}();\n\n/**\n * Creates a new tokenizer.\n *\n * Pass in input as first param or later using `input()`\n *\n * @param {string} [input=null] Optional input to tokenize\n * @param {Object} [options] options object\n * @param {boolean} [options.strict=true] strict mode\n * @param {boolean} [options.skipWhiteSpace=false] will ignore tokens containing only white space (basically all \\s)\n */\n\nvar ShortcodeTokenizer = function () {\n  function ShortcodeTokenizer() {\n    var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { strict: true, skipWhiteSpace: false };\n\n    _classCallCheck(this, ShortcodeTokenizer);\n\n    if (typeof options === 'boolean') {\n      options = { strict: options, skipWhiteSpace: false };\n    }\n    this.options = Object.assign({ strict: true, skipWhiteSpace: false }, options);\n    this.buf = null;\n    this.originalBuf = null;\n    this.pos = 0;\n    if (input) {\n      this.input(input);\n    }\n  }\n\n  /**\n   * @deprecated use options.strict\n   */\n  /* istanbul ignore next */\n\n\n  _createClass(ShortcodeTokenizer, [{\n    key: 'input',\n\n\n    /**\n     * Sets input buffer with a new input string.\n     *\n     * @param {string} input template string\n     * @throws {Error} Invalid input\n     * @returns {this} returns this for chaining\n     */\n    value: function input(_input) {\n      if (typeof _input !== 'string') {\n        throw new Error('Invalid input');\n      }\n\n      this.buf = this.originalBuf = _input;\n      this.pos = 0;\n      return this;\n    }\n\n    /**\n     * Resets input buffer and position to their origial values.\n     *\n     * @returns {this} returns this for chaining\n     */\n\n  }, {\n    key: 'reset',\n    value: function reset() {\n      this.buf = this.originalBuf;\n      this.pos = 0;\n      return this;\n    }\n\n    /**\n     * Creates a token generator.\n     *\n     * @throws {Error} Invalid input\n     * @returns {Token[]} An array of Token instances\n     */\n\n  }, {\n    key: 'tokens',\n    value: function tokens() {\n      var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n      if (input) {\n        this.input(input);\n      }\n\n      if (typeof this.buf !== 'string') {\n        throw new Error('Invalid input');\n      }\n\n      var tokens = [];\n      var allTokens = [];\n      while ((tokens = this._next()) !== null) {\n        tokens = Array.isArray(tokens) ? tokens : [tokens];\n        allTokens.push.apply(allTokens, _toConsumableArray(tokens));\n      }\n      return allTokens;\n    }\n\n    /**\n     * Uses the tokens generator to build an AST from the tokens.\n     *\n     * @see tokens\n     * @returns {array} an array of AST roots\n     */\n\n  }, {\n    key: 'ast',\n    value: function ast() {\n      var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n      var tokens = this.tokens(input);\n      var stack = [];\n      var ast = [];\n      var parent = null;\n      var token = void 0;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = tokens[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          token = _step.value;\n\n          if (token.type === TEXT) {\n            if (this.options.skipWhiteSpace && token.body.replace(/\\s+/g, '').length === 0) {\n              continue;\n            }\n            if (!parent) {\n              ast.push(token);\n            } else {\n              parent.children.push(token);\n            }\n          } else if (token.type === OPEN) {\n            if (!parent) {\n              parent = token;\n              ast.push(parent);\n            } else {\n              parent.children.push(token);\n              stack.push(parent);\n              parent = token;\n            }\n          } else if (token.type === CLOSE) {\n            if (!parent || !token.canClose(parent)) {\n              if (this.options.strict) {\n                throw new SyntaxError('Unmatched close token: ' + token.body);\n              } else {\n                var err = new Token(ERROR, token.body);\n                if (!parent) {\n                  ast.push(err);\n                } else {\n                  parent.children.push(err);\n                }\n              }\n            } else {\n              parent.isClosed = true;\n              parent = stack.pop();\n            }\n          } else if (token.type === SELF_CLOSING) {\n            if (!parent) {\n              ast.push(token);\n            } else {\n              parent.children.push(token);\n            }\n          } else {\n            /* istanbul ignore next */\n            throw new SyntaxError('Unknown token: ' + token.type);\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      if (parent) {\n        if (this.options.strict) {\n          throw new SyntaxError('Unmatched open token: ' + parent.body);\n        } else {\n          ast.push(new Token(ERROR, token.body));\n        }\n      }\n      return ast;\n    }\n\n    /**\n     * Build template by given token.\n     *\n     * @param {Token} token\n     * @param {object|string|null} [params=null]\n      * @throws {Error} Unexpected token type.\n     * @returns {string}\n     */\n\n  }, {\n    key: 'buildTemplate',\n    value: function buildTemplate(token) {\n      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      if (!token) {\n        return '';\n      }\n\n      if (!(token instanceof Token)) {\n        throw new Error('Expected Token instance.');\n      }\n\n      var build = function build(value) {\n        var childs = value.children.map(function (child) {\n          return child.children.length ? build(child) : child.toString();\n        });\n\n        return value.toString(params).replace('{slot}', childs.join(''));\n      };\n\n      return build(token);\n    }\n\n    /**\n     * Internal function used to retrieve the next token from the current\n     * position in the input buffer.\n     *\n     * @private\n     * @returns {Token} returns the next Token from the input buffer\n     */\n\n  }, {\n    key: '_next',\n    value: function _next() {\n      if (!this.buf) {\n        return null;\n      }\n\n      var match = this.buf.match(rxEnclosure);\n\n      // all text\n      if (match === null) {\n        var token = new Token(TEXT, this.buf, this.pos);\n        this.pos += this.buf.length;\n        this.buf = null;\n        return token;\n      }\n\n      var tokens = [];\n\n      // first part is text\n      if (match.index !== 0) {\n        tokens.push(new Token(TEXT, this.buf.substring(0, match.index), this.pos));\n      }\n\n      // matching token\n      tokens.push(new Token(getTokenType(match[0]), match[0], this.pos + match.index));\n\n      // shorten buffer\n      this.buf = this.buf.substring(match.index + match[0].length);\n      this.pos += match.index + match[0].length;\n      if (this.buf.length === 0) {\n        this.buf = null;\n      }\n      return tokens;\n    }\n  }, {\n    key: 'strict',\n    get: function get() {\n      console.warn('Deprecated: use options.strict instead');\n      return this.options.strict;\n    }\n\n    /**\n     * @deprecated use options.strict\n     */\n    /* istanbul ignore next */\n    ,\n    set: function set(value) {\n      console.warn('Deprecated: use options.strict = ' + value + ' instead');\n      this.options.strict = value;\n    }\n  }]);\n\n  return ShortcodeTokenizer;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (ShortcodeTokenizer);\n\n\nObject.assign(ShortcodeTokenizer, {\n  TEXT: TEXT,\n  ERROR: ERROR,\n  OPEN: OPEN,\n  CLOSE: CLOSE,\n  SELF_CLOSING: SELF_CLOSING,\n  rxParams: rxParams,\n  rxEnclosure: rxEnclosure,\n  rxOpen: rxOpen,\n  rxClose: rxClose,\n  rxSelfclosing: rxSelfclosing\n});\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// shortcode-tokenizer.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 60dc1c00a4c07e144bd5","/** @module ShortcodeTokenizer */\n\n/* tokens */\nconst TEXT = 'TEXT'\nconst ERROR = 'ERROR'\nconst OPEN = 'OPEN'\nconst CLOSE = 'CLOSE'\nconst SELF_CLOSING = 'SELF_CLOSING'\n\n/* eslint-disable */\n\n/* matches code name */\nconst RX_KEY = '[a-zA-Z][a-zA-Z0-9_-]*'\n\n/* matches paramters */\nconst RX_PARAM =       RX_KEY + '=\\\\d+\\\\.\\\\d+' +         // floats\n                 '|' + RX_KEY + '=\\\\d+' +                // ints\n                 '|' + RX_KEY + '=(true|false|yes|no)' + // bools\n                 '|' + RX_KEY + '=\"[^\\\\]\"]*(<.*\".*)?\"' +          // double-qouted strings\n                 '|' + RX_KEY + '=\\'[^\\\\]\\']*(<.*\\'.*)?\\'' +       // single-qouted strings\n                 '|' + RX_KEY                            // flags\nconst RX_PARAMS = '(?:(?:' + RX_PARAM + ')(?:(?!\\\\s+/?\\\\])\\\\s|))+'\n\n/* matches all code token types, used for quickly\n   finding potentia code tokens */\nconst RX_ENCLOSURE   = '\\\\[\\\\/?[a-zA-Z][^\\\\]]+\\\\]'\n/* matches opening code tokens [row] */\nconst RX_OPEN        = '\\\\[(' + RX_KEY + ')(\\\\s' + RX_PARAMS + ')?\\\\]'\n/* matches self-closing code tokens [row/] */\nconst RX_SELFCLOSING = '\\\\[(' + RX_KEY + ')(\\\\s' + RX_PARAMS + ')?\\\\s?\\\\/\\\\]'\n/* matches close code tokens [/row] */\nconst RX_CLOSE       = '\\\\[\\\\/(' + RX_KEY + ')\\\\]'\n\n/* case-insensitive regular expressions */\nconst rxParams      = new RegExp(RX_PARAMS.substring(0, RX_PARAMS.length - 1), 'ig')\nconst rxEnclosure   = new RegExp(RX_ENCLOSURE, 'i')\nconst rxOpen        = new RegExp(RX_OPEN, 'i')\nconst rxClose       = new RegExp(RX_CLOSE, 'i')\nconst rxSelfclosing = new RegExp(RX_SELFCLOSING, 'i')\n\n/* eslint-enable */\n\n/**\n * Get token type based on token-string.\n *\n * Note: assuming that this is not a TEXT token\n *\n * @param {string} str\n * @returns {string} token type\n */\nfunction getTokenType(str) {\n  if (str[1] === '/') {\n    return CLOSE\n  }\n  if (str[str.length - 2] === '/') {\n    return SELF_CLOSING\n  }\n  return OPEN\n}\n\n/**\n * Casts input string to native types.\n *\n * @param {string} value\n * @returns {*} mixed value\n */\nfunction castValue(value) {\n  if (/^\\d+$/.test(value)) return Number(value)\n  if (/^\\d+.\\d+$/.test(value)) return Number(value)\n  if (/^(true|false|yes|no)$/i.test(value)) {\n    value = value.toLowerCase()\n    return value === 'true' || value === 'yes'\n  }\n  return value.replace(/(^['\"]|['\"]$)/g, '')\n}\n\n/**\n * Token class is used both as a token during tokenization/lexing\n * and as a node in the resulting AST.\n */\nexport class Token {\n  constructor(type, body, pos = 0) {\n    this.name = null\n    this.type = type\n    this.body = body\n    this.pos = pos\n    this.children = []\n    this.params = {}\n    this.isClosed = type === SELF_CLOSING\n    this.init()\n  }\n\n  /**\n   * @access private\n   */\n  init() {\n    if (this.type !== TEXT && this.type !== ERROR) {\n      const match = this.matchBody()\n      this.initName(match)\n      if (match[2]) {\n        this.initParams(match[2])\n      }\n    }\n  }\n\n  /**\n   * @access private\n   */\n  initName(match) {\n    this.name = match[1]\n  }\n\n  /**\n   * @access private\n   */\n  initParams(paramStr) {\n    const match = paramStr.match(rxParams)\n    this.params = match.reduce((params, paramToken) => {\n      paramToken = paramToken.trim()\n      let equal = paramToken.indexOf('=')\n      if (!~equal) {\n        params[paramToken] = true\n      } else {\n        params[paramToken.substring(0, equal)] = castValue(paramToken.substring(equal + 1))\n      }\n      return params\n    }, {})\n  }\n\n  /**\n   * @return {string}\n   */\n  buildParams() {\n    let result = ''\n\n    for (const key in this.params) {\n      if (this.params.hasOwnProperty(key)) {\n        const value = this.params[key];\n        const typeOfValue = typeof value\n        if (typeOfValue === 'string') {\n          result = `${result} ${key}=\"${value}\"`\n        } else if (typeOfValue === 'boolean') {\n          const value_ = value ? 'true' : 'false'\n          result = `${result} ${key}=${value_}`\n        } else {\n          result = `${result} ${key}=${value}`\n        }\n      }\n    }\n\n    return result\n  }\n\n  /**\n   * Convert token to string.\n   *\n   * @param {object|string|null} [params=null]\n   * @return {string}\n   */\n  toString(params = null) {\n    if (params instanceof Object) {\n      this.params = params\n    }\n\n    const computedParams = typeof params === 'string'\n      ? ` ${params.trim()}`\n      : this.buildParams()\n\n    switch (this.type) {\n      case TEXT:\n        return this.body\n\n      case OPEN:\n        return `[${this.name}${computedParams}]${this.children.length ? '{slot}' : ''}[/${this.name}]`\n\n      case SELF_CLOSING:\n        return `[${this.name}${computedParams}/]`\n\n      default:\n        return ''\n    }\n  }\n\n  /**\n   * @access private\n   */\n  matchBody() {\n    let rx\n    if (this.type === CLOSE) {\n      rx = rxClose\n    } else if (this.type === OPEN) {\n      rx = rxOpen\n    } else if (this.type === SELF_CLOSING) {\n      rx = rxSelfclosing\n    } else {\n      throw new SyntaxError('Unknown token: ' + this.type)\n    }\n\n    let match = this.body.match(rx)\n    if (match === null) {\n      throw new SyntaxError('Invalid ' + this.type + ' token: ' + this.body)\n    }\n    return match\n  }\n\n  /**\n   * Determines if this token can close the param token.\n   *\n   * @access public\n   * @param {Token} token another token\n   * @returns {boolean}\n   */\n  canClose(token) {\n    return this.name === token.name\n  }\n}\n\n/**\n * Creates a new tokenizer.\n *\n * Pass in input as first param or later using `input()`\n *\n * @param {string} [input=null] Optional input to tokenize\n * @param {Object} [options] options object\n * @param {boolean} [options.strict=true] strict mode\n * @param {boolean} [options.skipWhiteSpace=false] will ignore tokens containing only white space (basically all \\s)\n */\nexport default class ShortcodeTokenizer {\n\n  constructor(input = null, options = {strict: true, skipWhiteSpace: false}) {\n    if (typeof options === 'boolean') {\n      options = {strict: options, skipWhiteSpace: false}\n    }\n    this.options = Object.assign({strict: true, skipWhiteSpace: false}, options)\n    this.buf = null\n    this.originalBuf = null\n    this.pos = 0\n    if (input) {\n      this.input(input)\n    }\n  }\n\n  /**\n   * @deprecated use options.strict\n   */\n  /* istanbul ignore next */\n   get strict() {\n    console.warn(`Deprecated: use options.strict instead`)\n    return this.options.strict\n  }\n\n  /**\n   * @deprecated use options.strict\n   */\n  /* istanbul ignore next */\n  set strict(value) {\n    console.warn(`Deprecated: use options.strict = ${value} instead`)\n    this.options.strict = value\n  }\n\n  /**\n   * Sets input buffer with a new input string.\n   *\n   * @param {string} input template string\n   * @throws {Error} Invalid input\n   * @returns {this} returns this for chaining\n   */\n  input(input) {\n    if (typeof input !== 'string') {\n      throw new Error('Invalid input')\n    }\n\n    this.buf = this.originalBuf = input\n    this.pos = 0\n    return this\n  }\n\n  /**\n   * Resets input buffer and position to their origial values.\n   *\n   * @returns {this} returns this for chaining\n   */\n  reset() {\n    this.buf = this.originalBuf\n    this.pos = 0\n    return this\n  }\n\n  /**\n   * Creates a token generator.\n   *\n   * @throws {Error} Invalid input\n   * @returns {Token[]} An array of Token instances\n   */\n  tokens(input = null) {\n    if (input) {\n      this.input(input)\n    }\n\n    if (typeof this.buf !== 'string') {\n      throw new Error('Invalid input')\n    }\n\n    let tokens = []\n    let allTokens = []\n    while ((tokens = this._next()) !== null) {\n      tokens = Array.isArray(tokens) ? tokens : [tokens]\n      allTokens.push(...tokens)\n    }\n    return allTokens\n  }\n\n  /**\n   * Uses the tokens generator to build an AST from the tokens.\n   *\n   * @see tokens\n   * @returns {array} an array of AST roots\n   */\n  ast(input = null) {\n    let tokens = this.tokens(input)\n    let stack = []\n    let ast = []\n    let parent = null\n    let token\n    for (token of tokens) {\n      if (token.type === TEXT) {\n        if (this.options.skipWhiteSpace && token.body.replace(/\\s+/g, '').length === 0) {\n          continue\n        }\n        if (!parent) {\n          ast.push(token)\n        } else {\n          parent.children.push(token)\n        }\n      } else if (token.type === OPEN) {\n        if (!parent) {\n          parent = token\n          ast.push(parent)\n        } else {\n          parent.children.push(token)\n          stack.push(parent)\n          parent = token\n        }\n      } else if (token.type === CLOSE) {\n        if (!parent || !token.canClose(parent)) {\n          if (this.options.strict) {\n            throw new SyntaxError('Unmatched close token: ' + token.body)\n          } else {\n            let err = new Token(ERROR, token.body)\n            if (!parent) {\n              ast.push(err)\n            } else {\n              parent.children.push(err)\n            }\n          }\n        } else {\n          parent.isClosed = true\n          parent = stack.pop()\n        }\n      } else if (token.type === SELF_CLOSING) {\n        if (!parent) {\n          ast.push(token)\n        } else {\n          parent.children.push(token)\n        }\n      } else {\n        /* istanbul ignore next */\n        throw new SyntaxError('Unknown token: ' + token.type)\n      }\n    }\n    if (parent) {\n      if (this.options.strict) {\n        throw new SyntaxError('Unmatched open token: ' + parent.body)\n      } else {\n        ast.push(new Token(ERROR, token.body))\n      }\n    }\n    return ast\n  }\n\n  /**\n   * Build template by given token.\n   *\n   * @param {Token} token\n   * @param {object|string|null} [params=null]\n\n   * @throws {Error} Unexpected token type.\n   * @returns {string}\n   */\n  buildTemplate(token, params = null) {\n    if (!token) {\n      return ''\n    }\n\n    if (!(token instanceof Token)) {\n      throw new Error('Expected Token instance.')\n    }\n\n    const build = (value) => {\n      const childs = value.children.map(\n        child => (child.children.length ? build(child) : child.toString())\n      )\n\n      return value.toString(params).replace('{slot}', childs.join(''))\n    }\n\n    return build(token)\n  }\n\n  /**\n   * Internal function used to retrieve the next token from the current\n   * position in the input buffer.\n   *\n   * @private\n   * @returns {Token} returns the next Token from the input buffer\n   */\n  _next() {\n    if (!this.buf) {\n      return null\n    }\n\n    let match = this.buf.match(rxEnclosure)\n\n    // all text\n    if (match === null) {\n      let token = new Token(TEXT, this.buf, this.pos)\n      this.pos += this.buf.length\n      this.buf = null\n      return token\n    }\n\n    let tokens = []\n\n    // first part is text\n    if (match.index !== 0) {\n      tokens.push(new Token(\n        TEXT,\n        this.buf.substring(0, match.index),\n        this.pos\n      ))\n    }\n\n    // matching token\n    tokens.push(new Token(\n      getTokenType(match[0]),\n      match[0],\n      this.pos + match.index\n    ))\n\n    // shorten buffer\n    this.buf = this.buf.substring(match.index + match[0].length)\n    this.pos += match.index + match[0].length\n    if (this.buf.length === 0) {\n      this.buf = null\n    }\n    return tokens\n  }\n}\n\nObject.assign(ShortcodeTokenizer, {\n  TEXT,\n  ERROR,\n  OPEN,\n  CLOSE,\n  SELF_CLOSING,\n  rxParams,\n  rxEnclosure,\n  rxOpen,\n  rxClose,\n  rxSelfclosing\n})\n\n\n\n// WEBPACK FOOTER //\n// ./src/shortcode-tokenizer.js"],"sourceRoot":""}